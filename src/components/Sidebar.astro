---
export interface Props {
  title: string;
  items: Array<{
    href: string;
    text: string;
  }>;
}

const { title, items } = Astro.props;
---

<aside class="sidebar">
  <div class="sidebar-content">
    <h3 class="sidebar-title">{title}</h3>
    <nav class="toc">
      <ul class="toc-list">
        {items.map(item => (
          <li>
            <a href={item.href} class="toc-link">{item.text}</a>
          </li>
        ))}
      </ul>
    </nav>
  </div>
</aside>

<script>
  console.log('Sidebar script starting...');
  
  // 等待DOM加载完成
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSidebar);
  } else {
    initSidebar();
  }
  
  function initSidebar() {
    console.log('Sidebar script loaded');
    
    const tocLinks = document.querySelectorAll('.toc-link');
    const sections = document.querySelectorAll('h1[id], h2[id], h3[id]');
    
    console.log('Found tocLinks:', tocLinks.length);
    console.log('Found sections:', sections.length);

    // 平滑滚动到锚点
    tocLinks.forEach(link => {
      link.addEventListener('click', function(this: HTMLAnchorElement, e: Event) {
        e.preventDefault();
        const href = this.getAttribute('href');
        const targetId = href ? href.substring(1) : '';
        
        const targetElement = document.getElementById(targetId);
        if (targetElement) {
          const elementOffsetTop = (targetElement as HTMLElement).offsetTop;
          const navbar = document.querySelector('.navbar') as HTMLElement;
          const navbarHeight = navbar ? navbar.offsetHeight : 88;
          const offsetTop = elementOffsetTop - navbarHeight - 50; // 调整偏移量
          
                  // 设置滚动标志，防止中间状态被选中
        isScrollingToTarget = true;
        
        // 手动更新活动状态，立即选中目标
        tocLinks.forEach(l => l.classList.remove('active'));
        this.classList.add('active');
        lastActiveSection = targetId;
        
        // 滚动到目标位置
        window.scrollTo({
          top: offsetTop,
          behavior: 'smooth'
        });
        history.pushState(null, '', '#' + targetId);
        
        // 滚动完成后重置标志
        setTimeout(() => {
          isScrollingToTarget = false;
        }, 1000); // 给滚动动画足够的时间
        }
      });
    });

    // 滚动监听，更新活动链接
    let lastActiveSection = '';
    let isScrollingToTarget = false;
    
    function updateActiveLink() {
      // 如果正在滚动到目标位置，不更新活动状态
      if (isScrollingToTarget) {
        return;
      }
      const scrollTop = window.pageYOffset;
      const navbar = document.querySelector('.navbar') as HTMLElement;
      const navbarHeight = navbar ? navbar.offsetHeight : 88;
      const offset = navbarHeight + 100; // 增加偏移量，避免选中过早
      
      let currentSection = null;
      
      // 如果滚动位置在页面顶部，选中第一个章节
      if (scrollTop < offset) {
        if (sections.length > 0) {
          const firstSectionId = sections[0].getAttribute('id');
          currentSection = firstSectionId;
        }
      } else {
        // 从后往前查找，找到最后一个已经滚动过的章节
        for (let i = sections.length - 1; i >= 0; i--) {
          const section = sections[i];
          const rect = section.getBoundingClientRect();
          const sectionId = section.getAttribute('id');
          
          // 如果章节的顶部已经滚动过了，就选中这个章节
          if (rect.top <= offset) {
            currentSection = sectionId;
            break;
          }
        }
      }
      
      // 如果没有找到任何章节，保持上一个选中的章节
      if (!currentSection) {
        currentSection = lastActiveSection;
      }
      
      // 只有当章节真正改变时才更新
      if (currentSection !== lastActiveSection) {
        lastActiveSection = currentSection;
        
        tocLinks.forEach(link => {
          link.classList.remove('active');
          const href = link.getAttribute('href');
          if (href && href === '#' + currentSection) {
            link.classList.add('active');
          }
        });
      }
    }

            // 节流函数
        let ticking = false;
        function requestTick() {
          if (!ticking) {
            requestAnimationFrame(() => {
              updateActiveLink();
              ticking = false;
            });
            ticking = true;
          }
        }
      
        window.addEventListener('scroll', requestTick);
        updateActiveLink(); // 初始化
        
        // 初始化通用锚点链接处理
        // 处理所有锚点链接
        const anchorLinks = document.querySelectorAll('a[href^="#"]');
        anchorLinks.forEach(link => {
          link.addEventListener('click', function(this: HTMLAnchorElement, e: Event) {
            e.preventDefault();
            const href = this.getAttribute('href');
            if (!href) return;
            
            const targetId = decodeURIComponent(href.substring(1));
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
              const elementOffsetTop = (targetElement as HTMLElement).offsetTop;
              const navbar = document.querySelector('.navbar') as HTMLElement;
              const navbarHeight = navbar ? navbar.offsetHeight : 88;
              const offsetTop = elementOffsetTop - 150;
              
              window.scrollTo({
                top: offsetTop,
                behavior: 'smooth'
              });
              history.pushState(null, '', href);
            }
          });
        });
  }
</script>
